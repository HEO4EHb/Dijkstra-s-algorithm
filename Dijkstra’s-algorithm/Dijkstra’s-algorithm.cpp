#include <iostream>
using namespace std;
#include <limits.h>
//Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности.
//Это отражает то, что расстояния от a до других вершин пока неизвестны.
//Все вершины графа помечаются как непосещённые.

//Если все вершины посещены, алгоритм завершается.
//В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку.
//Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом.
//Вершины, в которые ведут рёбра из u, назовём соседями этой вершины.
//Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, 
//равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.
//Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины.
// Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.
 

// колво вершин
#define V 9

// функция для нахождения мин расстояния 
// из не посещенных вершин
// 
int minDistance(int dist[], bool sptSet[])
{

    // мин значение делаем максимальным
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

// функция для вывода рассстояния
void printSolution(int dist[])
{
    cout << "Vertex \t Distance from Source" << endl;
    for (int i = 0; i < V; i++)
        cout << i << " \t\t\t\t" << dist[i] << endl;
}

// сам алгоритм дейктсры 
void dijkstra(int graph[V][V], int src)
{
    int dist[V]; // вывод.  dist[i] содержим самую маленькое расстояние от src до i
    

    bool sptSet[V]; // sptSet[i] будет если  i не наикратчайшая часть древа 
// или если кратчайшее расстояние от  src до i выведено

// делаем все расстояния "бесконечными"  и stpSet[]=0
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    // расстояние от начальной вершины до её самой  0
    dist[src] = 0;

    // ищем наикратчайшие пути для всех вершин
    for (int count = 0; count < V - 1; count++) {
        // берём минимальное расстояние вершин  из непройденныз. u всегда эквивалента 
        // src в первой итерации .
        int u = minDistance(dist, sptSet);

        // отмечаем выбранную вершину как пройденную
        sptSet[u] = true;

        // обновляем расстояние соседним с нашей вершиной вершин
        for (int v = 0; v < V; v++)

            // обновляем  dist[v] если оно не в sptSet,
            // существует ребро из u в v, and расстояние от src к  v через u меньше значения  dist[v]            
            if (!sptSet[v] && graph[u][v]
                && dist[u] != INT_MAX
                && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    // выводим массив расстояний 
    printSolution(dist);
}


int main()
{

    /* Пример */
    int graph[V][V] = { { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
                        { 4, 0, 8, 0, 0, 0, 0, 11, 0 },
                        { 0, 8, 0, 7, 0, 4, 0, 0, 2 },
                        { 0, 0, 7, 0, 9, 14, 0, 0, 0 },
                        { 0, 0, 0, 9, 0, 10, 0, 0, 0 },
                        { 0, 0, 4, 14, 10, 0, 2, 0, 0 },
                        { 0, 0, 0, 0, 0, 2, 0, 1, 6 },
                        { 8, 11, 0, 0, 0, 0, 1, 0, 7 },
                        { 0, 0, 2, 0, 0, 0, 6, 7, 0 } };
    
    dijkstra(graph, 0);

    return 0;
}
